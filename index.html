<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>M3U8 Pro - å¤šçº¿ç¨‹åŠ é€Ÿç‰ˆ</title>
    <style>
        body { font-family: system-ui; text-align: center; padding: 40px; background: #f4f4f4; }
        .card { background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: inline-block; width: 550px; }
        #log { background: #111; color: #0f0; padding: 15px; height: 280px; overflow-y: auto; text-align: left; font-size: 11px; margin-top: 20px; border-radius: 5px; font-family: monospace; white-space: pre-wrap; }
        .btn { background: #0070f3; color: white; border: none; padding: 14px; border-radius: 6px; cursor: pointer; width: 100%; font-size: 16px; margin-top: 10px; font-weight: bold; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        .progress-container { width: 100%; background: #eee; border-radius: 5px; margin-top: 15px; height: 20px; position: relative; overflow: hidden; }
        .progress-bar { width: 0%; height: 100%; background: #22c55e; transition: width 0.3s; }
        .progress-text { position: absolute; width: 100%; text-align: center; font-size: 11px; line-height: 20px; color: #000; font-weight: bold; }
    </style>
</head>
<body>
    <div class="card">
        <h3>ğŸš€ M3U8 å¤šçº¿ç¨‹åˆå¹¶ (å¹¶è¡Œè§£å¯†)</h3>
        <div id="status" style="margin-bottom: 10px; font-weight: bold; color: #0070f3;">æ­£åœ¨æ¿€æ´»å¤šçº¿ç¨‹å¼•æ“...</div>
        
        <div class="progress-container">
            <div id="progressText" class="progress-text">å‡†å¤‡ä¸­...</div>
            <div id="progressBar" class="progress-bar"></div>
        </div>

        <button id="runBtn" class="btn" disabled>å†…æ ¸è½½å…¥ä¸­...</button>
        <div id="log">æ­£åœ¨æ£€æµ‹æµè§ˆå™¨ SharedArrayBuffer æ”¯æŒ...</div>
    </div>

    <script>
        const statusEl = document.getElementById('status');
        const logEl = document.getElementById('log');
        const btn = document.getElementById('runBtn');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');

        const log = (m) => { logEl.innerText += `\n> ${m}`; logEl.scrollTop = logEl.scrollHeight; };
        let ffmpeg = null;

        async function initSystem() {
            try {
                // 1. æ£€æŸ¥è·¨åŸŸéš”ç¦»ç¯å¢ƒ
                if (!window.crossOriginIsolated) {
                    log("è­¦å‘Š: æœªæ£€æµ‹åˆ°è·¨åŸŸéš”ç¦»ç¯å¢ƒï¼Œå¤šçº¿ç¨‹å¯èƒ½å›é€€åˆ°å•çº¿ç¨‹ã€‚");
                }

                // 2. åŠ è½½ä¸»è„šæœ¬
                const script = document.createElement('script');
                script.src = '/ffmpeg.js';
                document.head.appendChild(script);
                await new Promise(r => script.onload = r);

                const { FFmpeg } = window.FFmpegWASM || window.FFmpeg;
                ffmpeg = new FFmpeg();

                // 3. ç›‘å¬å†…æ ¸æ—¥å¿—
                ffmpeg.on('log', ({ message }) => {
                    if (message.includes('Opening')) {
                        const match = message.match(/index\/(.+?\.ts)/);
                        if (match) statusEl.innerText = `ğŸ”“ æ­£åœ¨è§£å¯†: ${match[1]}`;
                    }
                    log(`[FFmpeg] ${message}`);
                });

                // 4. åŠ è½½å¤šçº¿ç¨‹å†…æ ¸
                const baseURL = window.location.origin;
                await ffmpeg.load({
                    coreURL: baseURL + '/ffmpeg-core.js',
                    wasmURL: baseURL + '/ffmpeg-core.wasm',
                    workerURL: baseURL + '/ffmpeg-core.worker.js' // å¤šçº¿ç¨‹å¿…é¡»
                });

                statusEl.innerText = "âœ… å¤šçº¿ç¨‹å¼•æ“å°±ç»ª";
                btn.innerText = "é€‰æ‹©æ–‡ä»¶å¤¹å¼€å§‹åŠ é€Ÿåˆå¹¶";
                btn.disabled = false;
                log("ç³»ç»Ÿå·²å°±ç»ªã€‚å¤šçº¿ç¨‹å·²å¼€å¯ï¼Œå¤„ç† 2000+ æ–‡ä»¶å°†æ˜¾è‘—å˜å¿«ã€‚");

                btn.onclick = startProcess;
            } catch (err) {
                statusEl.innerText = "âŒ å¯åŠ¨å¤±è´¥";
                log("é”™è¯¯: " + err.message);
            }
        }

        async function startProcess() {
            try {
                const rootHandle = await window.showDirectoryPicker();
                btn.disabled = true;
                log(`å·²é”å®šç›®å½•: ${rootHandle.name}`);

                // 1. åˆ›å»ºè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿé•œåƒ
                try { await ffmpeg.createDir('index'); } catch(e) {}

                let m3u8Content = "";
                let tsCount = 0;

                // 2. æ·±åº¦æ‰«æå¹¶æ‰¹é‡å†™å…¥
                for await (const entry of rootHandle.values()) {
                    if (entry.name === 'index.m3u8') {
                        const file = await entry.getFile();
                        m3u8Content = await file.text();
                    } 
                    else if (entry.kind === 'directory' && entry.name === 'index') {
                        const tasks = [];
                        for await (const subEntry of entry.values()) {
                            const file = await subEntry.getFile();
                            const task = (async (f, name) => {
                                const data = new Uint8Array(await f.arrayBuffer());
                                await ffmpeg.writeFile(`index/${name}`, data);
                                if (name.endsWith('.ts')) tsCount++;
                            })(file, subEntry.name);
                            tasks.push(task);
                        }
                        statusEl.innerText = "ğŸ“¥ æ­£åœ¨è½½å…¥æ–‡ä»¶åˆ°å†…å­˜...";
                        await Promise.all(tasks); // å¹¶è¡Œå†™å…¥è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ
                    }
                }

                if (!m3u8Content) throw new Error("æœªæ‰¾åˆ° index.m3u8");

                // 3. è·¯å¾„é€‚é…
                m3u8Content = m3u8Content.replace(/URI="([^"]+)"/g, (m, p1) => `URI="index/${p1.split('/').pop()}"`);
                await ffmpeg.writeFile('index.m3u8', m3u8Content);

                // 4. æ‰§è¡Œå¤šçº¿ç¨‹æŒ‡ä»¤
                log(`å¼€å§‹è§£å¯†åˆå¹¶ ${tsCount} ä¸ªç‰‡æ®µ...`);
                const startTime = Date.now();

                await ffmpeg.exec([
                    '-allowed_extensions', 'ALL',
                    '-i', 'index.m3u8',
                    '-c', 'copy',
                    '-bsf:a', 'aac_adtstoasc',
                    '-threads', '0', // è‡ªåŠ¨åˆ©ç”¨æ‰€æœ‰å¯ç”¨çº¿ç¨‹
                    'output.mp4'
                ]);

                // 5. å¯¼å‡º
                const resultData = await ffmpeg.readFile('output.mp4');
                const blob = new Blob([resultData.buffer], { type: 'video/mp4' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${rootHandle.name}_merged.mp4`;
                a.click();

                const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                statusEl.innerText = `ğŸ‰ åˆå¹¶å®Œæˆï¼è€—æ—¶ ${duration}ç§’`;
                btn.disabled = false;

            } catch (e) {
                log("å¤„ç†ä¸­æ–­: " + e.message);
                btn.disabled = false;
            }
        }

        initSystem();
    </script>
</body>
</html>